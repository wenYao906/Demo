# 事件响应链

## 一、iOS中事件的产生

说起到事件，就很容易让人想到Runloop，因为Runloop就是iOS中的事件处理框架。而我们在开发中常见的事件的产生也是由Runloop去消费的。

iOS中的事件分成好几种：

1. 触摸事件，手指触摸屏幕时产生
2. 加速事件，手机的陀螺仪以及加速度计产生的
3. 远程控制事件，使用其他远程控制设备控制，例如蓝牙设备



来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





1. 响应者对象：只有继承自UIRespone的对象才可以接受并响应事件，我们称为“响应者对象”。
2. 响应者对象有：UIApplication、UIWindow、UIViewController、UIView。以及继承自UIView的UIKit类。
3. UIRespone的子类都可以重写下面的四个方法来处理不同的触摸事件

```objective-c
// 1. 一根或者多根手指开始触摸屏幕
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event

// 2.一根或者多根手指在屏幕上移动（随着手指的移动，会持续调用该方法）
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event

// 3.一根或者多根手指离开屏幕
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event

// 4.触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
```

#### 事件响应链机制的流程如下所示：

 (1) 运行循环检测到屏幕被点击了，首先通知UIApplication找找谁被点击了；

 (2) UIApplication通知UIWindow去找找谁被点击了；

 (3) UIWindow告诉控制器去找找谁被点击了；

 (4) 控制器通知view去找找谁被点击了；

 (5) view会通知内部的btn看看是不是被点击了；

(6) btn发现是自己被点击了，于是他告诉view它被点击了；

 (7) view再告诉控制器是btn被点击了；

 (8) 控制器再告诉UIwindow是btn被点击了；

 (9) UIWindow在告诉UIApplication是button被点击了；

 (10) UIApplication再告诉runloop是btn被点击了；

 (11) runloop最后通知控制控制器执行点击方法；

<img src="/Users/study/Desktop/WYSwiftDemo/平时文章摘要/photo/UIButton的事件响应链.png" alt="UIButton的事件响应链" style="zoom:67%;" />



#### 如何确定触摸点所在的View?

根据hitTest方法获取的。

hitTest方法是UIResponder中的，每个继承自UIResponder的子类都会继承hitTest方法。

##### 它是如何查找的呢？

它的查找比较像深度优先遍历。

1. 先去找UIApplication下的第一个window；
2. 如果触摸点在当前的范围内，就去找当前window的第一个controller。
3. 如果触摸点在当前范围内，controller就会去找他的第一个view；
4. 如果触摸点不在第一个view，就会去找他的第二个view；
5. 直到找到view x为止，然后再不断地返回view x。

伪代码如下：

```objective-c
- (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    // 如果交互未打开，或者透明度小于0.05 或者 视图被隐藏
    if (self.userInteractionEnabled == NO || self.alpha < 0.05 || self.hidden == YES)
    {
        return nil;
    }
    // 如果 touch 的point 在 self 的bounds 内
    if ([self pointInside:point withEvent:event])
    {
        NSInteger count = self.subviews.count;
        for ( int i = 0; i < count; I++)
        {
            UIView* subView = self.subviews[count - 1 - I];
            // 进行坐标转化
            CGPoint coverPoint = [subView convertPoint:point fromView:self];
            // 调用子视图的 hitTest 重复上面的步骤。找到了，返回hitTest view ,没找到返回有自身处理
            UIView *hitTestView = [subView hitTest:coverPoint withEvent:event];
            if (hitTestView)
            {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
```

注：如果在某个view重写了hitTest，在hitTest中阻隔了系统继续再往下查找(比如直接return self)，那么最终找到的的view 可能未必是包含该触摸点的最小view。



#### 扩大button的点击范围

pointInside:withEvent: 方法可以改变点击范围。

```objective-c
// 返回视图层级中能响应触控点的最深视图
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  
// 返回视图是否包含指定的某个点
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   // default returns YES if point is in bounds
```



#### UIView不接受触摸事件的四种情况

**1. 当前视图或父视图不接收用户交互：** `userInteractionEnabled = NO` 提示：UIImageView的`userInteractionEnabled`默认就是NO，因此`UIImageView`以及它的子控件默认是不能接收触摸事件的

**2. 隐藏：** `hidden = YES`

**3. 透明：** `alpha = 0.0 ~ 0.01`

**4. 当前视图虽添加在父视图上，但是位置偏移出父视图即子视图的位置超出了父视图的有效位置**

 eg:黄色view添加在绿色view上，但是偏移出view范围，虽然黄色view可以展示，但是点击黄色view时，是后面白色的大view去响应了点击。 此处提示：如果设置了绿色`view.clipsToBounds = YES;`这句代码，含义就是裁剪超出绿色view的范围，那么黄色view就不会显示了。







#### 参考文章：

作者：Albert_Duan
链接：https://juejin.cn/post/7078881520517120014

作者：brownfeng（iOS的响应链小结）
链接：https://juejin.cn/post/7005112607707398157



